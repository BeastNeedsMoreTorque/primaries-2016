#!/usr/bin/env ruby
#
# This is meant to run as a daemon. It's basically cron with benefits.
#
# RUNNING
#
# The server creates `tmp/production-server.sock` and reads it, waiting for
# commands such as `exit\n` or `poll_dates 2016-02-01\n`. If no command comes
# before the timeout, it does its default polling.
#
# To run a command, run `script/run-production-command "exit"`. That opens
# `tmp/production-server.sock` for writing and opens
# `tmp/production-server-output.sock` for reading. The server will open
# `tmp/production-server-output.sock` for writing, so the server's output
# will be redirected to the `run-production-command` process, which will dump
# it on stderr.

require 'time'

require_relative '../lib/env'
require_relative '../lib/paths'
require_relative '../lib/api_sources'
require_relative '../lib/with_airbrake'
require_relative '../app/models/database'
require_relative '../config/schedule'

FileUtils.mkdir_p(Paths.ProductionDir)

for path in [ Paths.ProductionCommands, Paths.ProductionOutput ]
  FileUtils.rm_f(path)
  File.mkfifo(path)
end

class Server
  include ServerSchedule

  def initialize
    @command_reader = open(Paths.ProductionCommands, 'r+')
    @output_writer = open(Paths.ProductionOutput, 'a+')
    @output_writer.sync = true
    @real_stderr = $stderr.dup

    @views = Dir[File.dirname(__FILE__) + '/../app/views/*.rb'].map do |path|
      if path =~ /base_view.rb$/
        nil
      else
        require File.absolute_path(path)
        basename = path.split('/').last.split('.').first
        class_name = basename.gsub(/(^|_)([^_]+)/) { $2.capitalize }
        Object.const_get(class_name)
      end
    end.compact
  end

  def run
    WithAirbrake.run { run_scheduled_tasks }

    loop { wait_and_handle_command_or_run_scheduled_tasks }
  end

  private

  def run_scheduled_tasks
    if RefreshDelegates
      $logger.info('Updating delegate counts from AP')
      ignoring_ap_quota_error { ApiSources.poll_del_super }
    end

    if !RefreshPrimariesRaceDays.empty?
      $logger.info("Updating race-day results for #{RefreshPrimariesRaceDays.join(', ')} from AP")
      ignoring_ap_quota_error { ApiSources.poll_dates(RefreshPrimariesRaceDays) }
    end

    if RefreshDelegates || !RefreshPrimariesRaceDays.empty?
      archive_path = "#{Paths.CacheArchive}/#{Time.now.utc.iso8601}.tar.gz".gsub(':', '-')

      $logger.info("Saving AP data to #{archive_path}")
      system(
        'tar',
        '-C', Paths.Cache,
        '-zcf', archive_path,
        "--exclude=pollster*",
        "--exclude=sprockets",
        "--exclude=templates",
        "--exclude=*.etag",
        '.'
      )
    end

    if RefreshPollsterPrimaries
      $logger.info('Updating Pollster primaries estimates')
      ApiSources.poll_pollster_primaries
    end

    $logger.info("Wiping old output")
    FileUtils.rm_rf(Paths.Dist)

    $logger.info("Generating")

    Assets.build

    database = Database.load
    for view in @views
      view.generate_all(database)
    end

    $logger.info("Uploading")
    system("#{Paths.Script}/upload")
  end

  def ignoring_ap_quota_error(&block)
    begin
      block.call
    rescue RuntimeError => e
      valid_message = 'HTTP 500'
      if e.message[0 .. valid_message.length] != valid_message && e.message =~ /QuotaViolation/
        $logger.info("AP's API reports a quota violation. Falling back to cached results.")
      else
        raise e
      end
    end
  end

  # Waits up to TimeoutInS seconds for an incoming command, then runs it.
  #
  # If no command arrives, runs scheduled tasks as configured in
  # `config/schedule.rb`.
  def wait_and_handle_command_or_run_scheduled_tasks
    if IO.select([ @command_reader ], nil, nil, TimeoutInS)
      WithAirbrake.run { handle_command }
    else
      WithAirbrake.run { run_scheduled_tasks }
    end
  end

  def handle_command
    command = @command_reader.gets.strip
    $logger.info("Handling command: #{command}")

    $stderr.reopen(@output_writer)

    parts = command.split(/\s+/)

    case parts[0]
    when 'poll_dates' then run_poll_dates(parts[1..-1])
    when 'exit'
      $logger.info("Exiting")
      $stderr.write("\n") # so client can exit -- see below
      exit 0
    else
      $logger.warn("Ignoring invalid command `#{command}`")
    end

    # The client is running this command until output finishes. Write an empty
    # line to indicate the end of output.
    $stderr.write("\n")
    $stderr.reopen(@real_stderr)
  end
end

Server.new.run
