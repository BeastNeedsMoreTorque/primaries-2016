.horse-races
  - parties.each do |party|
    .horse-race{class: "party-#{party.id}", 'data-n-delegates': party.n_delegates_total, 'data-n-delegates-needed': party.n_delegates_needed}
      %h3= party.name
      %ol.candidate-horses
        - party.candidates.reject(&:dropped_out?).reverse.each do |candidate|
          %li.candidate-horse{'data-candidate-id': candidate.id, 'data-n-delegates': candidate.n_delegates, 'data-n-unpledged-delegates': candidate.n_unpledged_delegates, class: (candidate.dropped_out? ? 'dropped-out' : '')}
            .marker{style: "left: #{(candidate.n_delegates || 0).to_f / party.n_delegates_needed * 100}%"}
              %img{src: image_path("horses/#{candidate.slug}-horse.png"), alt: ''}
              .speech-bubble
            .background

      %ol.candidate-targets
        - party.candidates.reject(&:dropped_out?).reverse.each do |candidate|
          %li.candidate-target{'data-candidate-id': candidate.id}
            .last-name= candidate.name
            %img{src: image_path("horses/#{candidate.slug}-target.png"), alt: ''}
            .n-delegates= format_int(candidate.n_delegates)

      .json-data= party.horse_race_data.to_json

      -# As for state descriptions: they rely on assets. (Really, we should put
      -# the SVG data in the models, but meh.) So we'll draw them as HTML and
      -# hide it.
      .json-state-paths
        - state_codes = party.party_race_days_with_pledged_delegates.flat_map(&:races).map(&:state_code)
        = state_codes.map{ |code| [ code, state_svg_outline_path(code) ] }.to_h.to_json

      %button.play Step!
